"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const express_1 = require("express");
const server_1 = require("../server");
const zaloController_1 = require("../controllers/zaloController");
const zaloService_1 = require("../services/zaloService");
const User_1 = __importDefault(require("../models/User"));
const ZaloMessage_1 = __importDefault(require("../models/ZaloMessage"));
const ZaloGuestUser_1 = __importDefault(require("../models/ZaloGuestUser"));
const mockUser_1 = require("../utils/mockUser");
const authenticateJWT_1 = require("../middleware/authenticateJWT");
const authorizeRole_1 = require("../middleware/authorizeRole");
const ZaloToken_1 = __importDefault(require("../models/ZaloToken"));
const zaloCallController_1 = require("../controllers/zaloCallController");
const zaloCallController_2 = require("../controllers/zaloCallController");
const zaloService_2 = require("../services/zaloService");
const router = (0, express_1.Router)();
const ONLINE_THRESHOLD_MS = 5 * 60 * 1000;
// Middleware parse text/plain
router.use('/webhook', (req, _res, next) => {
    if (req.is('text/*')) {
        let data = '';
        req.setEncoding('utf8');
        req.on('data', (chunk) => (data += chunk));
        req.on('end', () => {
            try {
                req.body = JSON.parse(data);
            }
            catch {
                req.body = {};
            }
            next();
        });
    }
    else
        next();
});
// Webhook Zalo POST
router.post('/webhook', async (req, res) => {
    try {
        let payload = req.body;
        if (typeof payload === 'string') {
            try {
                payload = JSON.parse(payload);
            }
            catch {
                payload = {};
            }
        }
        console.log('üì• Zalo webhook payload:', payload);
        res.status(200).send('OK'); // tr·∫£ 200 ngay
        // x·ª≠ l√Ω cu·ªôc g·ªçi t·ª´ kh√°ch h√†ng
        if (payload?.event_name === "user_click_button" &&
            payload?.message?.button?.payload === "CALL_NOW") {
            const sender = payload?.sender || payload?.user;
            const guestId = sender?.id;
            if (!guestId)
                return;
            console.log("üìû Kh√°ch b·∫•m 'G·ªçi t∆∞ v·∫•n ngay' ‚Üí t·∫°o inbound call cho admin");
            try {
                await axios_1.default.post(`${process.env.BACKEND_URL || "https://homenest-webcare-fork-backend.onrender.com"}/api/zalo/call/inbound`, {
                    guestId,
                    guestName: "Kh√°ch h√†ng Zalo",
                    callLink: `https://zalo.me/oa/${process.env.ZALO_OA_ID || "2405262870078293027"}`,
                    targetRole: "admin",
                });
            }
            catch (err) {
                console.error("‚ùå L·ªói g·ªçi inboundCallController:", err.message);
            }
            return; // d·ª´ng x·ª≠ l√Ω ti·∫øp
        }
        // x·ª≠ l√Ω tinh nh·∫Øn vƒÉn b·∫£n
        const sender = payload?.sender ?? payload?.user ?? null;
        if (!sender?.id)
            return;
        const userId = sender.id;
        const text = payload?.message?.text ?? '[no text]';
        // Upsert GuestUser v·ªõi mock n·∫øu ch∆∞a c√≥
        const guestData = (0, mockUser_1.createMockUser)(userId);
        const guest = await ZaloGuestUser_1.default.findOneAndUpdate({ _id: userId }, { $set: { lastInteraction: new Date(), zaloId: userId }, $setOnInsert: guestData }, { upsert: true, new: true });
        const profile = await (0, zaloService_1.fetchZaloUserDetail)(userId);
        const saved = await ZaloMessage_1.default.create({
            userId,
            text,
            username: profile?.name ?? guest.username,
            avatar: profile?.avatar ?? guest.avatar,
            senderType: 'customer', // th√™m senderType
            success: true,
            response: payload,
        });
        // Emit realtime cho admin, k√®m tr·∫°ng th√°i online
        const admins = await User_1.default.find({ role: 'admin' });
        admins.forEach((a) => server_1.io.to(a._id.toString()).emit('new_message', {
            ...saved.toObject(),
            isOnline: guest?.lastInteraction
                ? Date.now() - guest.lastInteraction.getTime() < ONLINE_THRESHOLD_MS
                : false, // th√™m isOnline
        }));
        console.log(`üí¨ Saved message from userId=${userId}, username=${saved.username}`);
    }
    catch (err) {
        console.error('‚ùå Zalo webhook POST unexpected error:', err);
    }
});
// C√°c route kh√°c
router.get('/token', zaloController_1.getTokenController);
router.post('/send', authenticateJWT_1.authenticateToken, zaloController_1.sendMessageController);
// Conversations ‚Äì gom theo userId
router.get('/conversations', authenticateJWT_1.authenticateToken, (0, authorizeRole_1.authorizeRoles)(['admin', 'telesale']), async (req, res) => {
    try {
        const user = req.user;
        let messagesQuery = [];
        if (user.role === 'admin') {
            messagesQuery = await ZaloMessage_1.default.find().sort({ sentAt: 1 }).lean();
        }
        else {
            messagesQuery = await ZaloMessage_1.default.find({ assignedTelesale: user.id })
                .sort({ sentAt: 1 })
                .lean();
        }
        const conversations = {};
        for (const msg of messagesQuery) {
            const userId = typeof msg.userId === 'string' ? msg.userId : msg.userId._id.toString();
            if (!conversations[userId])
                conversations[userId] = { userId, messages: [] };
            const guest = await ZaloGuestUser_1.default.findById(userId);
            const isOnline = guest?.lastInteraction
                ? Date.now() - guest.lastInteraction.getTime() < ONLINE_THRESHOLD_MS
                : false;
            conversations[userId].messages.push({ ...msg, isOnline });
        }
        // üÜï B·ªï sung th√™m ph·∫ßn l·∫•y th√¥ng tin user (username, avatar, isOnline)
        const enrichedConversations = await Promise.all(Object.values(conversations).map(async (conv) => {
            const guest = await ZaloGuestUser_1.default.findById(conv.userId).lean();
            const latestMessage = conv.messages.length > 0 ? conv.messages[conv.messages.length - 1] : null;
            // ‚úÖ ƒê·∫øm tin nh·∫Øn ch∆∞a ƒë·ªçc
            const unreadCount = await ZaloMessage_1.default.countDocuments({
                userId: conv.userId,
                senderType: 'customer',
                read: false,
            });
            return {
                userId: conv.userId,
                username: guest?.username || 'Kh√°ch h√†ng',
                avatar: guest?.avatar || 'https://ui-avatars.com/api/?name=Guest&background=random',
                isOnline: guest?.isOnline ?? false,
                assignedTelesale: guest?.assignedTelesale || null,
                lastMessage: latestMessage?.text || '',
                lastSentAt: latestMessage?.sentAt || latestMessage?.createdAt,
                unreadCount,
                messages: conv.messages,
            };
        }));
        // S·∫Øp x·∫øp theo th·ªùi gian g·∫ßn nh·∫•t
        enrichedConversations.sort((a, b) => new Date(b.lastSentAt ?? 0).getTime() - new Date(a.lastSentAt ?? 0).getTime());
        res.json(enrichedConversations);
    }
    catch (err) {
        console.error('‚ùå /conversations error:', err);
        res.status(500).json({ error: err.message });
    }
});
// ƒê√°nh d·∫•u tin nh·∫Øn ƒë√£ ƒë·ªçc
router.patch('/messages/:userId/read', authenticateJWT_1.authenticateToken, async (req, res) => {
    try {
        const { userId } = req.params;
        const result = await ZaloMessage_1.default.updateMany({ userId, senderType: 'customer', read: false }, { $set: { read: true } });
        res.json({ success: true, modified: result.modifiedCount });
    }
    catch (err) {
        console.error('‚ùå /messages/:userId/read error:', err);
        res.status(500).json({ error: err.message });
    }
});
//
router.post('/assign-conversation', authenticateJWT_1.authenticateToken, (0, authorizeRole_1.authorizeRoles)(['admin']), async (req, res) => {
    try {
        const { userId, telesaleId } = req.body;
        if (!userId || !telesaleId) {
            res.status(400).json({ success: false, message: 'Thi·∫øu userId ho·∫∑c telesaleId' });
            return;
        }
        const result = await ZaloMessage_1.default.updateMany({ userId }, { $set: { assignedTelesale: telesaleId } });
        server_1.io.to(telesaleId).emit('assigned_conversation', { userId, telesaleId });
        res.json({ success: true, message: `ƒê√£ assign ${result.modifiedCount} tin nh·∫Øn`, userId });
    }
    catch (err) {
        console.error('‚ùå /assign-conversation error:', err);
        res.status(500).json({ success: false, message: err.message });
    }
});
// Assign telesale (admin only)
router.post('/assign-telesale', authenticateJWT_1.authenticateToken, (0, authorizeRole_1.authorizeRoles)(['admin']), async (req, res) => {
    try {
        const { messageId, telesaleId } = req.body;
        if (!messageId || !telesaleId) {
            res.status(400).json({ success: false, message: 'Thi·∫øu messageId ho·∫∑c telesaleId' });
            return;
        }
        // Ki·ªÉm tra messageId h·ª£p l·ªá
        if (!messageId.match(/^[0-9a-fA-F]{24}$/)) {
            res.status(400).json({
                success: false,
                message: 'messageId kh√¥ng h·ª£p l·ªá (ph·∫£i l√† ObjectId MongoDB)',
            });
            return;
        }
        const updated = await ZaloMessage_1.default.findByIdAndUpdate(messageId, { assignedTelesale: telesaleId }, { new: true });
        if (!updated) {
            res.status(404).json({ success: false, message: 'Kh√¥ng t√¨m th·∫•y message ƒë·ªÉ assign' });
            return;
        }
        server_1.io.to(telesaleId).emit('assigned_message', updated);
        res.json({ success: true, message: 'Assign telesale th√†nh c√¥ng', updated });
    }
    catch (err) {
        console.error('‚ùå /assign-telesale error:', err);
        res.status(500).json({ success: false, message: err.message });
    }
});
// Messages user
router.get('/messages/:userId', async (req, res) => {
    const { userId } = req.params;
    const role = req.query.role;
    const telesaleId = req.query.telesaleId;
    let query = { userId };
    if (role === 'telesale' && telesaleId)
        query.assignedTelesale = telesaleId;
    try {
        const messages = await ZaloMessage_1.default.find(query).sort({ sentAt: 1 }).lean();
        // th√™m tr·∫°ng th√°i online cho t·ª´ng message
        const messagesWithOnline = await Promise.all(messages.map(async (msg) => {
            const guest = await ZaloGuestUser_1.default.findById(msg.userId);
            const isOnline = guest?.lastInteraction
                ? Date.now() - guest.lastInteraction.getTime() < ONLINE_THRESHOLD_MS
                : false;
            return { ...msg, isOnline };
        }));
        res.json(messagesWithOnline);
    }
    catch (err) {
        console.error(err);
        res.status(500).json({ error: err.message });
    }
});
// List telesales
router.get('/telesales', async (req, res) => {
    try {
        const telesales = await User_1.default.find({ role: 'telesale' }).select('id username email phone');
        res.json(telesales);
    }
    catch (err) {
        res.status(500).json({ error: err.message });
    }
});
//=====================CAll zalo==========================
// G·ªçi ƒëi·ªán tho·∫°i zalo t·ª´ crm -> kh√°ch h√†ng
router.post('/call/create', async (req, res, next) => {
    console.log('üöÄ ƒê√£ nh·∫≠n POST /api/zalo/call/create t·ª´ crm t·ªõi kh√°ch h√†ng v·ªõi body:', req.body);
    next();
}, zaloCallController_1.createCallController);
//G·ªçi ƒëi·ªán tho·∫°i zalo t·ª´ kh√°ch h√†ng ->  crm 
router.post('/call/inbound', async (req, res, next) => {
    console.log('üöÄ ƒê√£ nh·∫≠n POST /api/zalo/call/inbound t·ª´ kh√°ch h√†ng t·ªõi crm v·ªõi body:', req.body);
    next();
}, zaloCallController_2.inboundCallController);
//route m·ªõi ƒë·ªÉ g·ª≠i tin nh·∫Øn OA c√≥ n√∫t ‚ÄúG·ªçi ngay‚Äù ƒë·∫øn kh√°ch h√†ng
router.post("/send-call-button", async (req, res) => {
    try {
        const { userId, productName } = req.body;
        const accessToken = await (0, zaloService_2.getAccessToken)();
        const message = {
            recipient: { user_id: userId },
            message: {
                attachment: {
                    type: "template",
                    payload: {
                        template_type: "button",
                        text: `üìû B·∫°n mu·ªën g·ªçi t∆∞ v·∫•n ngay v·ªÅ s·∫£n ph·∫©m "${productName}"?`,
                        buttons: [
                            {
                                title: "üìû G·ªçi t∆∞ v·∫•n ngay",
                                type: "oa.query.hide", // ho·∫∑c "oa.query.show"
                                payload: "CALL_NOW",
                            },
                        ],
                    },
                },
            },
        };
        const zaloRes = await axios_1.default.post("https://openapi.zalo.me/v3.0/oa/message", message, {
            headers: {
                access_token: accessToken,
                "Content-Type": "application/json",
            },
        });
        console.log("‚úÖ G·ª≠i th√†nh c√¥ng n√∫t g·ªçi t∆∞ v·∫•n:", zaloRes.data);
        res.json({ success: true, data: zaloRes.data });
    }
    catch (err) {
        console.error("‚ùå L·ªói g·ª≠i tin nh·∫Øn g·ªçi t∆∞ v·∫•n:", err.message);
        res.status(500).json({ success: false, message: err.message });
    }
});
//============================================================
//ki·ªÉm tra Access Token & Refresh Token hi·ªán t·∫°i m√† backend l∆∞u trong MongoDB
router.get('/token/latest', async (_req, res) => {
    const token = await ZaloToken_1.default.findOne().sort({ createdAt: -1 });
    res.json(token);
});
exports.default = router;
